<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style.css">
    <title>Capítulo 2</title>
</head>
<body>
    <h1>
        Variables y constantes.
    </h1>
    <h2>
        Definición de variables.
    </h2>
    <p>
        Si deseo imprimir los resultados de multiplicar un número fijo por otro que adopta valores entre 0 y 9,
        la forma normal de programar esto sería crear una constante para el primer número y un par de variables para 
        el segundo y para el resultado del producto. Una variable, en realidad, no es más que un nombre para identificar 
        una (o varias) posiciones de memoria donde el programa guarda los distintos valores de una misma entidad. 
        Un programa debe definir a todas las variables que utilizará, antes de comenzar a usarlas, a fin de indicarle al 
        compilador de que tipo serán, y por lo tanto cuanta memoria debe destinar para albergar a cada una de ellas. 
        Veamos el EJEMPLO 2. <br>
        Ejemplo 2:
        <blockquote id="Ejemplo2">
            <code>
            <pre>
            #include &lt;stdio.h&gt;
            main()
            {
                int multiplicador;  /* Multiplicador como un entero */
                int multiplicando;  /* Multiplicando como un entero */
                int resultado;      /* Resultado como entero */
                multiplicador=1000; /* Asignación de valores */
                multiplicando = 2;
                resultado = multiplicando * multiplicador;
                printf("Resultado = %d\n", resultado) ; /* Muestro resultado */
                return 0;
            }
            </pre>
            </code>
        </blockquote>
        En las primeras líneas de texto dentro de main() defino mis variables como números enteros, es decir, del tipo
        "int" seguido de un identificador (nombre) de la misma. Este identificador puede tener la cantidad de caracteres 
        que se desee, sin embargo, de acuerdo al compilador que se use, este tomarña como significantes sólo los primeros 
        'n' de ellos, siendo por lo general 'n' igual a 32. Es conveniente darle a los identificadores de las variables, 
        nombres que tengan un significado que luego permita una fácil lectura del programa. Los identificadores deben 
        comenzar con una letra o con el símbolo de subrayado "_", pudiendo continuar con cualquier otro carácter alfanumérico 
        o el símbolo "_". El único símbolo no alfanumérico aceptado en un nombre es el "_". El lenguaje C es sensible al tipo 
        de letra usado; así tomará como variables distintas a una llamada "variable", de otra  escrita como "VARIABLE". Es una 
        converción entre los programadores de C escribir los nombres de las varaibles y las funciones con minúsculas, reservando 
        las mayúsculas para las constantes. <br>
        El compliador dará como error de "Definición incorrecta" a la definición de variables con nombres del tipo de: <br>
        4pesos $variable primer-variable !variable etc,etc.

        <cite>
            <strong>Nota:</strong>Los compiladores reservan determinados términos o palabras claves (keywords) para el uso sintáctico
            del lenguaje, tales como: asm,auto,break, case,char,do,for,etc. Si bien estas palabras están definidas para el ANSI C, los 
            distintos compiladores extienden esta definición a otros términos, por lo que es aconsejable leer la tabla 
            compleata de palabras reservadas del compilador que se b¡vaya a usar, para no utilizarlas en nombres de variables.
        </cite>
        Vemos en las dos lineas subsiguientes a la definición de las variables, que puedo ya asignarles valores (1000 y 2) y luego efectuar 
        el cálculo de la variable "resultado". Si prestamos ahora atención a la función printf(), ésta nos mostrará la forma de 
        visualizar el valor de una variable. Insertada en el texto a mostrar, aparece una secuencia de control de impresión "%d" que 
        indica, que en el lugar que ella ocupa, deberá ponerse el contenido de la variable (que aparece luego de cerradas las comillas que 
        marcan la finalización del texto, y separada del mismo por una coma)expresado como un número entero decimal. Así, si compilamos y 
        corremos el programa, obtendremos una salida:
        <blockquote>
            <code>
                Resultado=2000
            </code>
        </blockquote>
    </p>
    <h2>
        INICIALIZACIÓN DE VARIABLES.
    </h2>
    <p>
        Las variables del mismo tipo pueden definirse mediante una definiciónmúltiple separándolas mediante "," a saber: <br>
        <blockquote>
            <code>
                int multiplicador, multiplicando, resultado;
            </code>
        </blockquote>
        Esta sentencia es equivalente a las tres definiciones separadas en el ejemplo anterior. Las variables pueden tembién ser inicializadas 
        en el momento de definirse. 
        <blockquote>
            <code>
                int multiplicador=1000, multiplicando=2, resultado;
            </code>
        </blockquote>
        De esta manera el ejemplo 2 podría escribirse: <br>
        Ejemplo 2 BIS.
        <blockquote>
            <pre>
            <code>
            
                #include &lt;stdio.h&gt;
                main()
                {
                    int multiplicador=1000, multiplicando=2;
                    printf("Resultado: %d\n", multiplicando*multiplicador);
                    return 0;
                }
            
            </code>
            </pre>
        </blockquote>
        Obsérvese que en la primer sentencia se definen e inicializan simultáneamente ambas variables. La variable "resultado" la hemos desecho ya 
        que es innecesaria. Si analizamos la función printf() vemos que se ha reemplazado "resultado" por la operación entre las otras dos variables. 
        Esta es una de las particularidades del lenguaje C: en los parámetros pasados a las funciones pueden ponerse operaciones (incluso llamadas a 
        otras funciones), las que se realizan antes de ejecutarse la función, pasando finalmente a esta el valor resultante de las mismas. El 
        <a href="#ejemplo2">Ejemplo 2</a> funcionaexactamente igual que antes pero su código ahora es mucho más comparcto y claro.
    </p>
    <h2>
        TIPOS DE VARAIBLES.
    </h2>
    <h4>Variables del tipo entero.</h4>
    <p>
        En el ejemplo anterior definimos a las variables como enteros (int). <br>
        De acuerdo a la cantidad de bytes que reserve el compilador para este tipo de variable, queda determinado el "alcance" o maximo valor que puede
        adoptar la misma. Debido a que el tipo int ocupa dos bytes su alcance queda restringido al rango entre -32.768 y +32.767 (incluyendo en 0). <br>
        En caso de necesitar un rango más amplio, puede definirse la variable como "long int nombre_de_variable" o una forma más abreviada "long nombre_de_variable"
        Declarada de esta manera, nombre_de_variable puede alcanzar valores entre -2.347.483.648 y +2.347.483.647. <br>
        A la inversa, si se quisiera un enlace  menor al de int, podría definirse "short int" o "short", aunque por lo general, los compiladores modernos asignan 
        a este tipo el mismo alcance que "int". <br>
        Para variables de muy pequelo valor puede usarse el tipo "char" cuyo alcance está restringido a -128 y 127 y por lo general ocupa un único byte. <br>
        Todos los tipos citados hast ahora pueden alojar valores positivos o negativos y, aunque es redundante, esto puede explicitarse agregando el calificador 
        "signed" delante; por ejemplo:
        <blockquote>
            <code>
                signed int <br>
                signed long <br>
                signed long int <br>
                signed short <br>
                signed short init <br>
                signed char 
            </code>
        </blockquote>
        Si en cambio, tenemos una variable que sólo puede adoptar valores positivos (como por ejemplo la edad de una persona) podemos aumentar el alcance de cualquiera 
        de los tipos, restringiéndolos a que sólo representen valores sin signo por medio del calificador "unsigned". En la tabla 1 se resumen los alcances de los 
        distintos tipos de variables enteras.
        <table id="tabla1">
            <tr>
                <td>TIPO</td>
                <td>BYTES</td>
                <td>VALOR MINIMO</td>
                <td>VALOR MAXIMO</td>
            </tr>
            <tr>
                <td>signed char</td>
                <td>1</td>
                <td>-128</td>
                <td>127</td>
            </tr>
            <tr>
                <td>unsigned char</td>
                <td>1</td>
                <td>0</td>
                <td>255</td>
            </tr>
            <tr>
                <td>signed short</td>
                <td>2</td>
                <td>-32.768</td>
                <td>32.767</td>
            </tr>
            <tr>
                <td>unsigned short</td>
                <td>2</td>
                <td>0</td>
                <td>65.535</td>
            </tr>
            <tr>
                <td>signed int</td>
                <td>2</td>
                <td>-32.768</td>
                <td>32.767</td>
            </tr>
            <tr>
                <td>unsigned int</td>
                <td>2</td>
                <td>0</td>
                <td>65.535</td>
            </tr>
            <tr>
                <td>signed long</td>
                <td>4</td>
                <td>-2.147.483.648</td>
                <td>2.147.483.647</td>
            </tr>
            <tr>
                <td>unsigned long</td>
                <td>4</td>
                <td>0</td>
                <td>4.294.967.295</td>
            </tr>
        </table>
        Tabla-1. <br>
        <cite>
            <strong>Nota:</strong> Si se omite el calificador delante del tipo de la variable entera, éste se adopta por 
            omisión (default) como "signed".
        </cite>
    </p>
    <h4>Variables de número real o punto flotante.</h4>
    <p>
        Un número real o de punto flotante es aquel que además de una parte entera, posee fracciones de unidad. En nuestra convención numérica solemos escribirlos de la 
        siguiente manera: 2,87. Los compiladores usan en punto decimal, en vez de la coma, así el número Pi se escribirá: 3.14159. <br>
        La notación científica aceptada es: 2.4993E+02, equivalente a 2.4993*100 0 249.930 <br>
        de acuerdo a su alcance hay tres tipos de variables de punto flotante, las mismas están descritas en la tabla 2.
        <table>
            <tr>
                <td>TIPO</td>
                <td>BYTES</td>
                <td>VALOR MINIMO</td>
                <td>VALOR MAXIMO</td>
            </tr>
            <tr>
                <td>float</td>
                <td>4</td>
                <td>3.4E-38</td>
                <td>3.4E+38</td>
            </tr>
            <tr>
                <td>double</td>
                <td>8</td>
                <td>1.7E-308</td>
                <td>1.7E+308</td>
            </tr>
            <tr>
                <td>long double</td>
                <td>10</td>
                <td>3.4E-4932</td>
                <td>3.4E+4932</td>
            </tr>
        </table>
        Tabla-2 <br>
        Las variables de punto flotante son siempre con signo, y en el caso que el exponente sea positivo puede obviarse el signo del mismo.
    </p>

    <h4>
        Conversión automática de tipos.
    </h4>
    <p>
        Cuando dos o más tipos de variables distintas se encuentran dentro de una misma operación o expresión matemática, ocurre una conversión automática del tipo de las 
        variables. En todo momento de realizarse una operación  se aplica la siguiente secuencia de reglas de conversión (previamente a la realización de dicha operación).
        <ul>
            <li>Las variables de tipo char o short se cinvierten en int.</li>
            <li>Las variables del tipo float se convierten en double.</li>
            <li>Si alguno de los operandos es de mayor precisión que los demás, estos se convierten al tipo de aquel y el resultado es de este tipo.</li>
            <li>Si no se aplica la regla anterior y un openrando es del tipo unsigned el otro se convierte en unsigned y el resultado es de este tipo.</li>
        </ul>
        Las reglas 1 a 3 no presentan problemas, sólo nos dicen que previamente a realizar alguna operación las variables son promovidas a su instancia superior. Esto no implica 
        que se haya cambiado la cantidad de memoria que las aloja en forma permanente. Otro tipo de regla se aplica para la conversión en las asignaciones. <br>
        Si definimos los términos de una asignación como "lvalue" a la variable a la izquierda del signo igual y "rvalue" a la expresión a la derecha del mismo, es decir: <br>
        <blockquote>
            <code>
                "lvalue"="rvalue";
            </code>
        </blockquote>
        Posteriormente al cálculo del resultado de "rvalue" (de acuerdo con las reglas antes descritas), el tipo de este se iguala al del "lvalue". El resultado no se verá afectado si 
        el tipo de "lvalue" es igual o superior al del "rvalue", en caso contrario se efectuará un truncamiento o redondeo, según sea el caso.
        Por ejemplo, el pasaje de float a int provoca el truncamiento de la parte fraccionaria, en cambio de double a floar se hace por redondeo.
    </p>
    <h4>
        Enclavamiento de conversiones (casting).
    </h4>
    <p>
        Las conversiones automáticas pueden ser controladas a gusto por el programador, imponiendo  el tipo de variables al resultado de una operación. Supongamos por ejemplo tener:
        <blockquote>
            <pre>
                <code>
                    double d,e,f=1.23;
                    int i=6;
                    e=f*i;
                    d=(int)(f*i);
                </code>
            </pre>
        </blockquote>
        En la primera sentencia calculamos el valor del p4roducto (f*i), que según lo visto anteriormente nos dará un double de valor 13.98, el que se ha asignado a e. Si en la variable d 
        quisiéramos reservar sólo el valor entero de dicha operación bastará con anteponer, encerrado entre paréntesis, el tipo deseado. Así, en d, se almacenará el número 13.00. <br>
        También, es factible aplicar la fijación de tipo a una variable, por ejemplo obtendremos el mismo resultado, si hacemos: 
        <blockquote>
            <pre>
                <code>
                    d = (int) f*i;
                </code>
            </pre>
        </blockquote>
        En este caso hemos convertido a f en un entero (truncado sus decimales).
    </p>

    <h4>
        Variables de tipo carácter.
    </h4>
    <p>
        El lenguaje C guarda los caracteres como números de 8 bits de acuerdo a la norma ASCII extendida, que asigna a cada caracter un número comprendido entre 0 y 255 (un byte de 8 bits). 
        Es común entonces que las variables que vayan a alojar caracteres sean definidas como: <strong>char c;</strong>. Sin embargo, también, funciona de manera correcta definirla como: 
        <strong>int c;</strong>. Ésta desperdicia un poco más de memoria que la anterior, pero en algunos casos particulares presenta ciertas ventajas. Pongamos por caso una función 
        que lee un archivo de texto ubicado en un disco. Dicho archivo puede tener cualquier caracter ASCII de valor comprendido entre 0 y 255. Para que la función puede avisarme 
        que el archivo ha finalizado deberá enviar un número NO comprendido entre 0 y 255 (por lo general se usa el -1, denominado EOF, fin de archivo o End Of File), en este caso dicho número 
        no puede ser mantenido en una variable del tipo char, ya que esta sólo puede guardar entre 0 y 255 si se define unsigned o no podría mantener los caracteres comprendidos entre 128 y 255 
        si se define signed (ver <a href="#tabla1">tabla 1</a>). El problema se obvia fácilmente definiéndola como int. <br>
        Las variables del tipo carácter también pueden ser inicializadas en su definición, por ejemplo es válido escribir: 
        <blockquote>
            <pre>
                <code>
                    char c=97;
                </code>
            </pre>
        </blockquote>
        Para que 'c' contenga el valor ASCII de la letra "a", sin embargo, esto resulta algo engorroso, ya que obliga a recordar dichos códigos. Existe una manera más directa de asignar un caractér 
        a una variable; la sigueinte inicialización es idéntica a la anterior:
        <blockquote>
            <pre>
                <code>
                    char c='a';
                </code>
            </pre>
        </blockquote>
        Es decir que si delimitamos un caracter con comillas simples, el compilador entenderá que debe suplantarlo por su correspondiente código numérico.
        Lamentablemente existen una serie de caracteres que no son imprimibles, en otras palabras que cuando editemos nuestro  programa fuente (archivo de texto ) nos resultará defícil de asignarlas a 
        una variable ya que el editor las toma como un comando y no como un caracter. Un caso típico sería el de "nueva línea" o ENTER. <br>
        Con el fin de tener acceso a los mismos es que aparecen ciertas secuencias de escape convencionales. Las mismas estan listadas en la tabla 3 y su uso es 
        idéntico al de los caracteres normales, así para resolver el caso de una asignación de "nueva línea" se escribirá:
        <blockquote>
            <pre>
                <code>
                    char c='\n'; /* secuencia de escape */
                </code>
            </pre>
        </blockquote>

        tabla 3 - Secuencia de escape.
        <table>
            <tr>
                <td> _CÓDIGO _</td>
                <td> _SIGNIFICADO_ </td>
                <td> _VALOR ASCII (decimal)_</td>
                <td> _VALOR ASCII (hexadecimal)_</td>
            </tr>
            <tr>
                <td>\n</td>
                <td>nueva linea</td>
                <td>10</td>
                <td>0x0A</td>
            </tr>
            <tr>
                <td>\r</td>
                <td>retorno de carro</td>
                <td>13</td>
                <td>0x0D</td>
            </tr>
            <tr>
                <td>\f</td>
                <td>nueva página</td>
                <td>2</td>
                <td>0x0C</td>
            </tr>
            <tr>
                <td>\t</td>
                <td>tabulador horizontal</td>
                <td>9</td>
                <td>0x09</td>
            </tr>
            <tr>
                <td>\b</td>
                <td>retroceso (backspace)</td>
                <td>8</td>
                <td>0x08</td>
            </tr>
            <tr>
                <td>\'</td>
                <td>comilla simple</td>
                <td>39</td>
                <td>0x27</td>
            </tr>
            <tr>
                <td>\"</td>
                <td>comillas</td>
                <td>4</td>
                <td>0x22</td>
            </tr>
            <tr>
                <td>\\</td>
                <td>barra</td>
                <td>92</td>
                <td>0x5C</td>
            </tr>
            <tr>
                <td>\?</td>
                <td>interrogación</td>
                <td>63</td>
                <td>0x3F</td>
            </tr>
            <tr>
                <td>\nnn</td>
                <td>cualquier caracter (donde nnn es el código ASCII expresado en octal)</td>
            </tr>
            <tr>
                <td>\xnn</td>
                <td>cualquier caracter (donde nn es el código ASCII expresado en hexadecimal)</td>
            </tr>
        </table>
    </p>
</body>
</html>